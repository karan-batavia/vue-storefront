---
title: CI/CD
layout: default
navigation:
  icon: tabler:number-2-small
---

# Deployment - CI/CD

Ever wondered how to efficiently deploy multiple stores in a production environment? This guide explains how Continuous Integration (CI) and Continuous Deployment (CD) work in a multistore setup, making your deployment process smooth and reliable.

**What You'll Learn**

::list{type="success"}
- Understanding CI/CD in a multistore context
- How to implement change detection for stores
- How to set up parallel store deployments
- Best practices for any CI/CD platform
::

## Core Concepts

### What is CI/CD in Multistore?

In a multistore setup, CI/CD is designed to:
1. Automatically detect which stores have changed
2. Run tests only for affected stores
3. Deploy only the necessary stores to production

This targeted approach ensures:
- Faster deployments (only changed stores are processed)
- Efficient resource usage
- Reduced risk (unchanged stores remain untouched)

## Implementation Steps

Let's break down how to implement CI/CD for multiple stores, using GitHub Actions as an example while explaining how to adapt each step for other CI platforms.

### 1. Setting Up Dependencies

First, you need to set up your environment with the necessary dependencies:

```yaml
steps:
  # 1. Check out your code
  - name: Checkout code
    uses: actions/checkout@v4
    with:
      fetch-depth: 0  # Important: Need full history for change detection

  # 2. Set up Node.js
  - name: Install dependencies
    run: |
      npm install
      # Configure private registry if needed
      npm config set @your-scope:registry https://your-registry.com
```

::tip{title="Adapting for Other CI Platforms"}
Key requirements for any CI platform:
- Full git history access (for change detection)
- Node.js environment
- Access to your npm registry
- Environment variables for credentials
::

### 2. Change Detection

The change detection step identifies which stores need deployment:

```yaml
steps:
  - name: Find affected stores
    id: affectedStores
    run: |
      # Get list of changed stores
      STORE_IDS=$(yarn store changed --since ${{ github.event.pull_request.base.sha }} --condensed)
      
      # Format for CI platform
      echo "storeIds=$STORE_IDS" >> $GITHUB_OUTPUT
      
      # Create flag format for CLI
      if [ "$STORE_IDS" != "[]" ]; then
        STORE_FLAGS=$(echo $STORE_IDS | jq -r 'map("--store-id " + .) | join(" ")')
        echo "storeIdsFlag=$STORE_FLAGS" >> $GITHUB_OUTPUT
      fi
```

::tip{title="Implementing in Other CI Systems"}
To implement change detection:
1. Run `yarn store changed --since <previous-commit>`
2. Parse the JSON output into your CI platform's variable format
3. Use these variables to control subsequent steps
::

### 3. Running Tests

Once you know which stores changed, run tests only for those stores:

```yaml
steps:
  - name: Run integration tests
    if: ${{ steps.affectedStores.outputs.storeIds != '[]' }}
    run: |
      # Install test dependencies
      yarn playwright install --with-deps chromium
      
      # Run tests for affected stores
      yarn store test ${{ steps.affectedStores.outputs.storeIdsFlag }}
```

::tip{title="Cross-Platform Testing"}
Key considerations for any CI platform:
1. Install test dependencies
2. Use the store IDs from change detection
3. Set appropriate timeouts
4. Configure test result reporting
::

### 4. Building Stores

Before deployment, build the affected stores:

```yaml
steps:
  - name: Build affected stores
    if: ${{ steps.affectedStores.outputs.storeIds != '[]' }}
    run: |
      yarn store build ${{ steps.affectedStores.outputs.storeIdsFlag }}
```

### 5. Parallel Deployment

The final step is deploying the stores in parallel. Here's how to structure this in different CI systems:

::code-group
```yaml [GitHub Actions]
jobs:
  deploy:
    name: Deploy ${{ matrix.store_id }} store
    strategy:
      matrix:
        store_id: ${{ fromJson(needs.chooseStoresToDeploy.outputs.storeIds) }}
    steps:
      - name: Deploy store
        run: yarn store deploy --store-id ${{ matrix.store_id }}
```

```yaml [GitLab CI]
deploy:
  parallel:
    matrix:
      - STORE_ID: $STORE_IDS # Define this variable in previous stage
  script:
    - yarn store deploy --store-id $STORE_ID
```

```yaml [Jenkins Pipeline]
stage('Deploy') {
    steps {
        script {
            def storeIds = readJSON(text: STORE_IDS)
            parallel storeIds.collectEntries { storeId ->
                ["${storeId}" : {
                    sh "yarn store deploy --store-id ${storeId}"
                }]
            }
        }
    }
}
```
::

::tip{title="Implementing Parallel Deployments"}
Key requirements for any CI platform:
1. Support for parallel job execution
2. Ability to share variables between jobs
3. Individual job retry capabilities
4. Proper error handling and reporting
::

## Version Control

### CLI Version Management

It's crucial to use a fixed CLI version across all environments:

```yaml
steps:
  - name: Get CLI version
    id: cli_version
    run: |
      CLI_VERSION=$(jq -r '.dependencies["@alokai/cli"]' package.json)
      echo "Using CLI version: $CLI_VERSION"
      echo "CLI_VERSION=$CLI_VERSION" >> $GITHUB_OUTPUT

  - name: Deploy with specific version
    run: npx @alokai/cli@${{ steps.cli_version.outputs.CLI_VERSION }} store deploy
```

::warning{title="Version Consistency"}
Ensure the same CLI version is used in:
- Local development
- CI/CD pipelines
- Production deployments
::

## Best Practices

1. **Environment Setup**
   - Use dependency caching
   - Set up proper timeout values
   - Configure error reporting

2. **Change Detection**
   - Configure global dependencies properly
   - Use appropriate git depth
   - Handle branch merges correctly

3. **Deployment Strategy**
   - Implement proper rollback procedures
   - Set up deployment verification
   - Configure proper logging

## Common Pitfalls

1. **Git Configuration**
   - Insufficient git history depth
   - Missing branch information
   - Incorrect merge base detection

2. **Resource Management**
   - Excessive parallel jobs
   - Missing timeout configurations
   - Insufficient cleanup procedures

3. **Error Handling**
   - Missing failure notifications
   - Incomplete error logs
   - Poor retry mechanisms

::card{title="Next: CLI Reference" icon="tabler:number-3-small" }
#description
Learn more about the CLI commands used in CI/CD pipelines.

#cta
:::docs-arrow-link{to="/guides/multistore/tooling-and-concepts/cli-reference"}
Next
:::
::